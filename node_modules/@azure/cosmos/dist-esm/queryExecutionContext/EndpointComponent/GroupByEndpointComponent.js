import { __awaiter } from "tslib";
import { hashObject } from "../../utils/hashObject";
import { createAggregator } from "../Aggregators";
import { getInitialHeader } from "../headerUtils";
import { emptyGroup, extractAggergateResult } from "./emptyGroup";
/** @hidden */
export class GroupByEndpointComponent {
    constructor(executionContext, queryInfo) {
        this.executionContext = executionContext;
        this.queryInfo = queryInfo;
        this.groupings = new Map();
        this.aggreateResultArray = [];
        this.completed = false;
    }
    nextItem() {
        return __awaiter(this, void 0, void 0, function* () {
            // If we have a full result set, begin returning results
            if (this.aggreateResultArray.length > 0) {
                return { result: this.aggreateResultArray.pop(), headers: getInitialHeader() };
            }
            if (this.completed) {
                return { result: undefined, headers: getInitialHeader() };
            }
            // Grab the next result
            const { result, headers } = (yield this.executionContext.nextItem());
            // If it exists, process it via aggreatators
            if (result) {
                const group = result.groupByItems ? yield hashObject(result.groupByItems) : emptyGroup;
                const aggergators = this.groupings.get(group);
                const payload = result.payload;
                if (aggergators) {
                    // Iterator over all results in the payload
                    Object.keys(payload).map((key) => {
                        const aggregateResult = extractAggergateResult(payload[key]);
                        aggergators.get(key).aggregate(aggregateResult);
                    });
                }
                else {
                    // This is the first time we have seen a grouping. Setup the initial result without aggregate values
                    const grouping = new Map();
                    this.groupings.set(group, grouping);
                    // Iterator over all results in the payload
                    Object.keys(payload).map((key) => {
                        const aggregateType = this.queryInfo.groupByAliasToAggregateType[key];
                        // Create a new aggregator for this specific aggregate field
                        const aggreatator = createAggregator(aggregateType);
                        grouping.set(key, aggreatator);
                        if (aggregateType) {
                            const aggregateResult = extractAggergateResult(payload[key]);
                            aggreatator.aggregate(aggregateResult);
                        }
                        else {
                            aggreatator.aggregate(payload[key]);
                        }
                    });
                }
            }
            // It no results are left in the underling execution context, convert our results set to an array
            if (!this.executionContext.hasMoreResults()) {
                for (const grouping of this.groupings.values()) {
                    const groupResult = {};
                    for (const [aggregateKey, aggregator] of grouping.entries()) {
                        groupResult[aggregateKey] = aggregator.getResult();
                    }
                    this.aggreateResultArray.push(groupResult);
                }
                this.completed = true;
                return { result: this.aggreateResultArray.pop(), headers };
            }
            // Return empty items until we have a full results set
            return { result: undefined, headers };
        });
    }
    hasMoreResults() {
        return this.executionContext.hasMoreResults() || this.aggreateResultArray.length > 0;
    }
}
//# sourceMappingURL=GroupByEndpointComponent.js.map